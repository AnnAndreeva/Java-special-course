<h1 align="center">Лабораторные работы по специальному курсу Java.</h1>
<h2>Лабораторная работа № 1: Пакеты. Области видимости.</h2>
Цель задания: изучить структуру исходного кода программ на java, особенности областей видимости, структуру пакетов, особенности использования командной строки для компиляции и запуска программ на java.
Для выполнения задания использовать простейший текстовый редактор (блокнот). Для компиляции и запуска приложений использовать командную строку. Рекомендуется каждое задание выполнять в отдельном каталоге.

<h2>Лабораторная работа № 2: Классы.</h2>
В процессе написания тестовых заданий ознакомиться с основными конструкциями языка Java, правилами именования, структурированными типами и принципами создания классов.
<br>Создать класс, реализующий работу с векторами (набор вещественных чисел, координат) и базовые операции векторной арифметики. 
Экземпляр должен соответствовать вектору фиксированной длины (она задается как параметр конструктора). Конструктор без параметра не создавать.
Должны быть реализованы следующие методы:
<li>доступа к элементам вектора (получения значения и изменения значения),
<li>получения «длины» вектора (количества его элементов),
<li>поиска минимального и максимального значений из элементов вектора,
<li>сортировки вектора (по возрастанию или убыванию – на ваш выбор),
<li>нахождения евклидовой нормы,
<li>умножения вектора на число,
<li>сложения двух векторов (статический),
<li>нахождения скалярного произведения двух векторов (статический).


<h2>Лабораторная работа № 3: Интерфейсы. Исключительные ситуации.</h2>
В процессе написания тестовых заданий ознакомиться с концепцией интерфейсов и исключительными ситуациями в java.
<li>Описать два класса с идентичным внешним контрактом, принадлежащих одной предметной области (функциональная семантика предметной области выбирается самостоятельно). 
<li>Описать интерфейс, задающий список сигнатур методов доступа к полям объектов и функционального метода, оба класса должны реализовывать интерфейс.
<li> В классах корректно переопределить методы класса Object – toString(), equals(), hashCode().
<li>Разработать программное приложение, имеющее адекватный интерфейс пользователя, в котором организовать базу (массив) объектов типа интерфейс и заполнить ее объектами описанных типов вперемежку (по желанию пользователя приложения). Выполнить следующие действия:<br>
- вывести полную информацию обо всех объектах массива;<br>
- найти в массиве объекты, функциональный метод которых возвращают одинаковый результат, поместить такие объекты в другой массив; <br>
- разбить исходный массив на два массива, в которых будут храниться однотипные элементы;<br>
<li>При описании классов описать собственные исключения - одно объявляемое (наследное от Exception) и одно необъявляемое (наследное от RuntimeException) исключения, характеризующие ошибки, связанные с выполнением методов классов и учитывающие специфику исключения (объявляемость и необъявляемость). В соответствующих методах выбрасывать/при выбросе  контролировать описанные исключения.

<h2>Лабораторная работа № 4: Ввод/вывод. Сериализация.</h2>
В процессе написания тестовых заданий ознакомиться с потоковым механизмом ввода/вывода в java.
Модифицировать классы из лабораторной работы №3 следующим образом:<br>
<li>в интерфейс добавить следующие методы:
-- записи в байтовый поток<br>
void output(OutputStream out);<br>
-- записи в символьный поток <br>
void write(Writer out);<br>
<li>реализовать добавленные в интерфейс методы в обоих классах;
<li>описать новый класс со следующими статическими методами:
-- записи в байтовый поток<br>
void output<Интерфейс>(<Интерфейс> o, OutputStream out);<br>
-- чтения из байтового потока <br>
<Интерфейс> input<Интерфейс>(InputStream in);<br>
-- записи в символьный поток <br>
void write<Интерфейс> (<Интерфейс> o, Writer out);<br>
-- чтения из символьного потока <br>
<Интерфейс> read<Интерфейс>(Reader in);
 
<li>В статических методах записи делегировать вызов соответствующему методу интерфейса.
<li>В обоих случаях записанный объект должен представлять собой последовательность значений своих полей.
<li>В случае символьного потока рекомендуется считать, что один объект записывается в одну строку (поля разделены пробелами). Для чтения элемента из символьного потока можно использовать класс StreamTokenizer. или BufferesReader. 
 
<li>Модифицировать классы в иерархии таким образом, чтобы они были сериализуемы. Добавить в класс со статическими методами методы для вывода/ввода сериализованных объектов.<br>
-- вывод сериализованных объектов <br>
void serialize<Интерфейс> (<Интерфейс> o, OutputStream out);<br>
-- ввод десериализованного объекта <br>
<Интерфейс> deserialize<Интерфейс>(InputStream in);<br>

<li>Организовать примитивный интерфейс пользователя (заполнение базы элементов с консоли, выбор типа элемента пользователем). Протестировать разработанные методы работы с потоками, а также возможности сериализации.

 <h2>Лабораторная работа № 5: Потоки.</h2>
 В процессе написания тестовых заданий ознакомиться с общими принципами создания многопоточных приложений.
<li>Создать два класса нитей, наследующих от класса Thread, взаимодействующих друг с другом с помощью одного промежуточного объекта типа интерфейс из вашей иерархии (см л.р. №3).
Первая нить последовательно заполняет поле-массив промежуточного объекта (изначально он заполнен нулями) произвольными различными величинами (например, случайными), отличными от нуля. Каждый раз, когда она помещает значение в массив, она выводит на экран сообщение вида “Write: ### to position ###”. По достижении конца массива нить заканчивает свое выполнение.
Вторая нить последовательно считывает значения из массива и выводит их на экран сообщениями вида “Read: ### from position ###”. По достижении конца массива нить заканчивает свое выполнение.
В методе main() следует создать 3 участвующих в процессе объекта (две нити и объект интерфейса для записи/чтения в него) и запустить нити на выполнение. Запустите программу несколько раз. Попробуйте варьировать приоритеты нитей.
<li>
Создайте два новых класса нитей (реализуют интерфейс Runnable), обеспечивающих последовательность операций чтения-записи (т.е. на экран сообщения выводятся в порядке write-read-write-read-…) независимо от приоритетов потоков. Для этого потребуется описать некий вспомогательный класс <Интерфейс>Synchronizer, объект которого и будет использоваться при взаимодействии нитей. Протестируйте работу описанных классов.

<li>Добавить в класс со статическими методами обработки объектов (созданный в л. р. 4) реализацию метода <Интерфейс> synchronized<Интерфейс> (<Интерфейс> i), возвращающего ссылку на оболочку указанного интерфейса, безопасную с точки зрения многопоточности. Для этого потребуется описать новый класс, реализующий ваш интерфейс <Интерфейс> и представляющий собой оболочку, синхронизирующую все методы интерфейса (состоящую из синхронизированных методов вашего интерфейса). Протестировать его работу.

<h2>Лабораторная работа № 6: Итераторы. Декораторы. Фабрики.</h2>
В процессе написания тестовых заданий ознакомиться с механизмом образцов проектирования «Итератор», «Декоратор» и упрощенной версией «Фабричного метода».
<li>
Модифицировать ваш интерфейс таким образом, чтобы он реализовывал интерфейс java.util.Iterable<>.
Реализовать метод java.util.Iterator<> iterator(), унаследованный из интерфейса, в двух ваших классах. Для этого, естественно, следует описать некий дополнительный класс итератора с соответствующими методами итератора (из стандартного интерфейса java.util.Iterator<>). Объект итератора и возвращается из метода iterator() ваших классов. Итератор должен позволять обойти все элементы поля-массива.
<li>
Проверить работу итераторов с использованием цикла while и улучшенного цикла for.
<li>
Добавить в класс со статическими методами описание еще одного статического метода
 <Интерфейс> unmodifiable<Интерфейс>(<Интерфейс> о), возвращающего ссылку на экземпляр неизменяемой оболочки указанного объекта. Для этого нужно написать новый класс-декоратор для типа <Интерфейс>, который содержит объект типа <Интерфейс>, сам реализует <Интерфейс>, а все методы интерфейса делегирует внутреннему объекту, кроме методов изменения объекта. Декоратор выбрасывает исключение UnsupportedOperationException в случае попытки изменения состояния внутреннего объекта.
<li>
Описать новый интерфейс <Интерфейс>Factory, содержащий единственный метод createInstance() для создания экземпляра по умолчанию (опционально в фабрику можно добавить  методы с параметрами для создания объектов).
<li>
В классе со статическими методами создать приватное статическое поле factory типа <Интерфейс>Factory и соответствующий ему публичный метод set<Интерфейс>Factory(), позволяющие, соответственно, хранить ссылку и устанавливать ссылку на текущую фабрику объектов (ПРИМЕЧАНИЕ. Метода get<Интерфейс>Factory() не создавать!). Для каждого из двух классов вашей иерархии нужно описать класс соответствующей фабрики (реализующей метод createInstance()). По умолчанию поле должно ссылаться на объект некоторого (одного из двух) класса Factory, порождающего экземпляры одного из ваших классов.
<li>
В классе со статическими методами описать метод public static  createInstance(), с помощью текущей фабрики создающий новый экземпляр объекта. В остальных методах этого класса заменить прямое создание экземпляров на вызов этого метода. При тестировании (в методе main()) также создавать объекты только через вызов этого метода.


<h2>Лабораторная работа № 7: Swing.</h2>
В процессе написания задания с технологией Swing, обработкой событий и PLaF.
<li>
Написать оконное Swing-приложение для игры в «больше-меньше». Игра заключается в следующем: пользователь загадывает число из указанного диапазона, а разработанное приложение пытается его угадать. На каждое предположение приложения о загаданном числе пользователь указывает, является ли загаданное число больше, меньше, или приложение угадало. Реализовать приложение со следующей функциональностью:
 <br>-ввод минимального и максимального значений диапазона, из которого пользователь может загадать число;
 <br>-предположение приложения о загаданном пользователем числе;
 <br>-указание пользователя, является ли предположенное число больше или меньше загаданного;
 <br>-вывод завершающего сообщения о победе и предложение сыграть еще раз;
 <br>-вывод завершающего сообщения о жульничестве и предложение сыграть еще раз.
<li>
Добавить на форму радиокнопку на несколько позиций, соответствующих различным доступным PLaF. При выборе пользователем одного из предлагаемых значений должен изменяться внешний вид программы.

 <br><br>(2022 г.)
